// FILE: src/core/mod.rs

// 1. Declare the modules
pub mod constants;
pub mod types;
pub mod properties;
pub mod state;
pub mod util;

use crate::error::{CompilerError, Result};

// 2. Re-export the most important types for easy access
//    This prevents other files from having to write `use crate::core::state::CompilerState;`
//    and allows them to just write `use crate::core::CompilerState;`
pub use constants::*;
pub use core::*;
pub use properties::*;
pub use state::*;
pub use util::*;

use byteorder::{LittleEndian, ReadBytesExt};
use serde::Serialize;
use std::io::{Cursor, Read};

/// Information about a KRB file, generated by inspecting its header.
#[derive(Debug, Clone, Serialize)]
pub struct KrbFileInfo {
    pub version: (u8, u8),
    pub flags: u16,
    pub element_count: u16,
    pub style_count: u16,
    pub component_count: u16,
    pub animation_count: u16,
    pub script_count: u16,
    pub string_count: u16,
    pub resource_count: u16,
    pub element_offset: u32,
    pub style_offset: u32,
    pub component_offset: u32,
    pub animation_offset: u32,
    pub script_offset: u32,
    pub string_offset: u32,
    pub resource_offset: u32,
    pub total_size: u32,
}

impl KrbFileInfo {
    /// Checks if the file has a specific feature flag set.
    pub fn has_feature(&self, flag: u16) -> bool {
        (self.flags & flag) != 0
    }

    /// Gets a human-readable description of the file.
    pub fn description(&self) -> String {
        format!(
            "KRB v{}.{} - {} elements, {} styles, {} components, {} scripts, {} resources ({} bytes)",
            self.version.0, self.version.1,
            self.element_count, self.style_count, self.component_count,
            self.script_count, self.resource_count, self.total_size
        )
    }

    /// Calculates the compression ratio if the original size is known.
    pub fn compression_ratio(&self, original_size: u64) -> f64 {
        if original_size > 0 {
            self.total_size as f64 / original_size as f64
        } else {
            0.0
        }
    }
}

/// Validates a byte slice as a KRB file and extracts its header information.
pub fn validate_krb_file(data: &[u8]) -> Result<KrbFileInfo> {
    if data.len() < KRB_HEADER_SIZE {
        return Err(CompilerError::InvalidFormat {
            message: format!(
                "File too small: {} bytes, expected at least {}",
                data.len(),
                KRB_HEADER_SIZE
            ),
        });
    }

    let mut cursor = Cursor::new(data);

    let mut magic = [0u8; 4];
    cursor.read_exact(&mut magic)?;
    if &magic != KRB_MAGIC {
        return Err(CompilerError::InvalidFormat {
            message: format!("Invalid magic: {:?}, expected {:?}", magic, KRB_MAGIC),
        });
    }

    let version = cursor.read_u16::<LittleEndian>()?;
    let major = ((version >> 8) & 0xFF) as u8;
    let minor = (version & 0xFF) as u8;

    let flags = cursor.read_u16::<LittleEndian>()?;
    let element_count = cursor.read_u16::<LittleEndian>()?;
    let style_count = cursor.read_u16::<LittleEndian>()?;
    let component_count = cursor.read_u16::<LittleEndian>()?;
    let animation_count = cursor.read_u16::<LittleEndian>()?;
    let script_count = cursor.read_u16::<LittleEndian>()?;
    let string_count = cursor.read_u16::<LittleEndian>()?;
    let resource_count = cursor.read_u16::<LittleEndian>()?;
    
    // Skip the 3 reserved count fields in the v0.5 header
    let _ = cursor.read_u16::<LittleEndian>()?;
    let _ = cursor.read_u16::<LittleEndian>()?;
    let _ = cursor.read_u16::<LittleEndian>()?;


    let element_offset = cursor.read_u32::<LittleEndian>()?;
    let style_offset = cursor.read_u32::<LittleEndian>()?;
    let component_offset = cursor.read_u32::<LittleEndian>()?;
    let animation_offset = cursor.read_u32::<LittleEndian>()?;
    let script_offset = cursor.read_u32::<LittleEndian>()?;
    let string_offset = cursor.read_u32::<LittleEndian>()?;
    let resource_offset = cursor.read_u32::<LittleEndian>()?;
    
    // Skip the 3 reserved offset fields in the v0.5 header
    let _ = cursor.read_u32::<LittleEndian>()?;
    let _ = cursor.read_u32::<LittleEndian>()?;
    let _ = cursor.read_u32::<LittleEndian>()?;

    let total_size = cursor.read_u32::<LittleEndian>()?;

    if total_size as usize != data.len() {
        return Err(CompilerError::InvalidFormat {
            message: format!(
                "Size mismatch: header says {}, actual {}",
                total_size,
                data.len()
            ),
        });
    }

    Ok(KrbFileInfo {
        version: (major, minor),
        flags,
        element_count,
        style_count,
        component_count,
        animation_count,
        script_count,
        string_count,
        resource_count,
        element_offset,
        style_offset,
        component_offset,
        animation_offset,
        script_offset,
        string_offset,
        resource_offset,
        total_size,
    })
}